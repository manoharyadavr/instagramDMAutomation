[{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\admin\\affiliates\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":44,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1475,1478],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1475,1478],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getServerSession } from 'next-auth';\r\nimport { authOptions } from '@/lib/auth/options';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const session = await getServerSession(authOptions);\r\n\r\n        if (!session || session.user.role !== 'SUPERADMIN') {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n        }\r\n\r\n        const searchParams = req.nextUrl.searchParams;\r\n        const page = parseInt(searchParams.get('page') || '1');\r\n        const limit = parseInt(searchParams.get('limit') || '50');\r\n\r\n        const [affiliates, total] = await Promise.all([\r\n            prisma.affiliate.findMany({\r\n                skip: (page - 1) * limit,\r\n                take: limit,\r\n                orderBy: { totalEarnings: 'desc' },\r\n                include: {\r\n                    user: {\r\n                        select: {\r\n                            name: true,\r\n                            email: true,\r\n                        },\r\n                    },\r\n                },\r\n            }),\r\n            prisma.affiliate.count(),\r\n        ]);\r\n\r\n        return NextResponse.json({\r\n            affiliates,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\affiliate\\enroll\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":5,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[777,780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[777,780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":27,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1352,1355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1352,1355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { affiliateManager } from '@/lib/affiliate';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        // Enroll user as affiliate\r\n        const affiliate = await affiliateManager.enrollAffiliate(\r\n            tenant.user.id,\r\n            tenant.tenantId\r\n        );\r\n\r\n        return NextResponse.json({\r\n            message: 'Successfully enrolled in affiliate program',\r\n            affiliate: {\r\n                referralCode: affiliate.referralCode,\r\n                referralUrl: `${process.env.NEXTAUTH_URL}/signup?ref=${affiliate.referralCode}`,\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        // Get affiliate stats\r\n        const stats = await affiliateManager.getAffiliateStats(tenant.user.id);\r\n\r\n        if (!stats) {\r\n            return NextResponse.json(\r\n                { error: 'Not enrolled in affiliate program' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        return NextResponse.json({ stats });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\affiliate\\leaderboard\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[772,775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[772,775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { affiliateManager } from '@/lib/affiliate';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const searchParams = req.nextUrl.searchParams;\r\n        const limit = parseInt(searchParams.get('limit') || '10');\r\n\r\n        const topAffiliates = await affiliateManager.getTopAffiliates(limit);\r\n\r\n        // Remove sensitive information\r\n        const leaderboard = topAffiliates.map((affiliate, index) => ({\r\n            rank: index + 1,\r\n            name: affiliate.user.name || 'Anonymous',\r\n            totalEarnings: affiliate.totalEarnings,\r\n            totalReferrals: affiliate.totalReferrals,\r\n        }));\r\n\r\n        return NextResponse.json({ leaderboard });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\affiliate\\payouts\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1680,1683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1680,1683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":53,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":53,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2634,2637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2634,2637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { affiliateManager, AFFILIATE_CONFIG } from '@/lib/affiliate';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const body = await req.json();\r\n        const { amount, paymentMethod } = body;\r\n\r\n        // Get affiliate record\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { userId: tenant.user.id },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            return NextResponse.json(\r\n                { error: 'Not enrolled in affiliate program' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        // Validate payout amount\r\n        if (!amount || amount < AFFILIATE_CONFIG.minPayoutAmount) {\r\n            return NextResponse.json(\r\n                { error: `Minimum payout amount is â‚¹${AFFILIATE_CONFIG.minPayoutAmount}` },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        if (amount > affiliate.pendingPayout) {\r\n            return NextResponse.json(\r\n                { error: 'Insufficient pending payout' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Process payout (in production, integrate with payment gateway)\r\n        await affiliateManager.processPayout(affiliate.id, amount);\r\n\r\n        return NextResponse.json({\r\n            message: 'Payout request submitted successfully',\r\n            amount,\r\n            paymentMethod,\r\n            status: 'pending', // Would be updated once payment is processed\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        // Get payout history (would come from a separate PayoutLog table in production)\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { userId: tenant.user.id },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            return NextResponse.json(\r\n                { error: 'Not enrolled in affiliate program' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        return NextResponse.json({\r\n            pendingPayout: affiliate.pendingPayout,\r\n            totalEarnings: affiliate.totalEarnings,\r\n            minPayoutAmount: AFFILIATE_CONFIG.minPayoutAmount,\r\n            // In production, include payout history from PayoutLog table\r\n            payouts: [],\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\affiliate\\track\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1263,1266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1263,1266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { affiliateManager } from '@/lib/affiliate';\r\nimport { cookies } from 'next/headers';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const body = await req.json();\r\n        const { referralCode } = body;\r\n\r\n        if (!referralCode) {\r\n            return NextResponse.json(\r\n                { error: 'Referral code is required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Track the referral\r\n        await affiliateManager.trackReferral(referralCode, {\r\n            userAgent: req.headers.get('user-agent'),\r\n            referer: req.headers.get('referer'),\r\n            ip: req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip'),\r\n        });\r\n\r\n        // Set cookie to track referral for 30 days\r\n        const cookieStore = cookies();\r\n        cookieStore.set('ref_code', referralCode, {\r\n            maxAge: 30 * 24 * 60 * 60, // 30 days\r\n            httpOnly: true,\r\n            secure: process.env.NODE_ENV === 'production',\r\n            sameSite: 'lax',\r\n        });\r\n\r\n        return NextResponse.json({\r\n            message: 'Referral tracked successfully',\r\n            referralCode,\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\auth\\[...nextauth]\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\auth\\instagram\\callback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":61,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2427,2430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2427,2430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { exchangeCodeForToken, getPagesAndInstagramAccounts } from '@/lib/instagram/auth';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { getServerSession } from 'next-auth';\r\nimport { authOptions } from '@/lib/auth/options';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    const session = await getServerSession(authOptions);\r\n    if (!session || !session.user.tenantId) {\r\n        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    const searchParams = req.nextUrl.searchParams;\r\n    const code = searchParams.get('code');\r\n    const error = searchParams.get('error');\r\n\r\n    if (error) {\r\n        return NextResponse.json({ error }, { status: 400 });\r\n    }\r\n\r\n    if (!code) {\r\n        return NextResponse.json({ error: 'No code provided' }, { status: 400 });\r\n    }\r\n\r\n    try {\r\n        // 1. Exchange code for User Access Token\r\n        const { accessToken } = await exchangeCodeForToken(code);\r\n\r\n        // 2. Get connected IG accounts\r\n        const accounts = await getPagesAndInstagramAccounts(accessToken);\r\n\r\n        if (accounts.length === 0) {\r\n            return NextResponse.json({ error: 'No Instagram Business accounts found linked to your Facebook Pages.' }, { status: 404 });\r\n        }\r\n\r\n        // 3. Save to DB (Upsert)\r\n        // In a real app, we might ask the user to select WHICH account if multiple.\r\n        // For automation, we'll save all found or just the first one. Let's save all.\r\n        const savedAccounts = [];\r\n        for (const acc of accounts) {\r\n            const saved = await prisma.instagramAccount.upsert({\r\n                where: { instagramId: acc.instagramId },\r\n                update: {\r\n                    accessToken: accessToken, // Note: Ideally we should exchange for a Long-Lived Token first.\r\n                    username: acc.username,\r\n                    tenantId: session.user.tenantId,\r\n                },\r\n                create: {\r\n                    instagramId: acc.instagramId,\r\n                    username: acc.username,\r\n                    accessToken: accessToken,\r\n                    tenantId: session.user.tenantId,\r\n                },\r\n            });\r\n            savedAccounts.push(saved);\r\n        }\r\n\r\n        // Redirect to dashboard\r\n        return NextResponse.redirect(new URL('/dashboard/instagram', req.url));\r\n\r\n    } catch (err: any) {\r\n        console.error('IG Auth Error:', err);\r\n        return NextResponse.json({ error: err.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\billing\\history\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1130,1133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1130,1133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const searchParams = req.nextUrl.searchParams;\r\n\r\n        const page = parseInt(searchParams.get('page') || '1');\r\n        const limit = parseInt(searchParams.get('limit') || '50');\r\n\r\n        const [billingLogs, total] = await Promise.all([\r\n            prisma.billingLog.findMany({\r\n                where: { tenantId: tenant.tenantId },\r\n                orderBy: { createdAt: 'desc' },\r\n                skip: (page - 1) * limit,\r\n                take: limit,\r\n            }),\r\n            prisma.billingLog.count({\r\n                where: { tenantId: tenant.tenantId },\r\n            }),\r\n        ]);\r\n\r\n        return NextResponse.json({\r\n            billingLogs,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\billing\\subscriptions\\[id]\\cancel\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2202,2205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2202,2205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { razorpayClient } from '@/lib/razorpay';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nexport async function POST(\r\n    req: NextRequest,\r\n    { params }: { params: { id: string } }\r\n) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const body = await req.json();\r\n        const cancelAtCycleEnd = body.cancelAtCycleEnd || false;\r\n\r\n        // Get subscription\r\n        const subscription = await prisma.subscription.findFirst({\r\n            where: {\r\n                id: parseInt(params.id),\r\n                tenantId: tenant.tenantId,\r\n            },\r\n        });\r\n\r\n        if (!subscription) {\r\n            return NextResponse.json(\r\n                { error: 'Subscription not found' },\r\n                { status: 404 }\r\n            );\r\n        }\r\n\r\n        if (subscription.status === 'CANCELED') {\r\n            return NextResponse.json(\r\n                { error: 'Subscription is already cancelled' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Cancel in Razorpay\r\n        await razorpayClient.cancelSubscription(\r\n            subscription.razorpaySubId,\r\n            cancelAtCycleEnd\r\n        );\r\n\r\n        // Update in DB\r\n        const updated = await prisma.subscription.update({\r\n            where: { id: subscription.id },\r\n            data: {\r\n                status: cancelAtCycleEnd ? 'ACTIVE' : 'CANCELED', // Will be CANCELED at end if cancelAtCycleEnd\r\n            },\r\n        });\r\n\r\n        // Log billing event\r\n        await prisma.billingLog.create({\r\n            data: {\r\n                tenantId: tenant.tenantId,\r\n                amount: 0,\r\n                currency: 'INR',\r\n                description: `Subscription cancelled: ${subscription.razorpaySubId}`,\r\n                status: 'cancelled',\r\n            },\r\n        });\r\n\r\n        return NextResponse.json({\r\n            subscription: updated,\r\n            message: cancelAtCycleEnd\r\n                ? 'Subscription will be cancelled at the end of billing period'\r\n                : 'Subscription cancelled immediately',\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Cancel subscription error:', error);\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\billing\\subscriptions\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3881,3884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3881,3884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":114,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4534,4537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4534,4537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { razorpayClient } from '@/lib/razorpay';\r\nimport { SUBSCRIPTION_PLANS } from '@/lib/razorpay/plans';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { affiliateManager } from '@/lib/affiliate';\r\nimport { z } from 'zod';\r\nimport { cookies } from 'next/headers';\r\n\r\nconst createSubscriptionSchema = z.object({\r\n    planId: z.string(),\r\n    customerName: z.string(),\r\n    customerEmail: z.string().email(),\r\n    customerContact: z.string().optional(),\r\n    referralCode: z.string().optional(),\r\n});\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const body = await req.json();\r\n\r\n        // Check for referral code in cookie if not in body\r\n        const cookieStore = await cookies();\r\n        const refCodeCookie = cookieStore.get('ref_code');\r\n        if (!body.referralCode && refCodeCookie) {\r\n            body.referralCode = refCodeCookie.value;\r\n        }\r\n\r\n        const data = createSubscriptionSchema.parse(body);\r\n\r\n        // Check if tenant already has an active subscription\r\n        const existingSubscription = await prisma.subscription.findFirst({\r\n            where: {\r\n                tenantId: tenant.tenantId,\r\n                status: { in: ['ACTIVE', 'TRIALING'] },\r\n            },\r\n        });\r\n\r\n        if (existingSubscription) {\r\n            return NextResponse.json(\r\n                { error: 'You already have an active subscription. Please cancel it first.' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Create Razorpay subscription\r\n        const razorpaySubscription = await razorpayClient.createSubscription({\r\n            plan_id: data.planId,\r\n            customer_notify: 1,\r\n            total_count: 12, // 12 months for yearly, can be adjusted\r\n            quantity: 1,\r\n            notes: {\r\n                tenant_id: tenant.tenantId.toString(),\r\n                tenant_name: tenant.user.name || '',\r\n                referral_code: data.referralCode || '',\r\n            },\r\n        });\r\n\r\n        // Save to database\r\n        const subscription = await prisma.subscription.create({\r\n            data: {\r\n                tenantId: tenant.tenantId,\r\n                razorpaySubId: razorpaySubscription.id,\r\n                planId: data.planId,\r\n                status: 'ACTIVE', // Will be updated by webhook\r\n                currentPeriodStart: new Date(razorpaySubscription.current_start * 1000),\r\n                currentPeriodEnd: new Date(razorpaySubscription.current_end * 1000),\r\n            },\r\n        });\r\n\r\n        // Log billing event\r\n        await prisma.billingLog.create({\r\n            data: {\r\n                tenantId: tenant.tenantId,\r\n                amount: 0, // Will be updated when payment is captured\r\n                currency: 'INR',\r\n                description: `Subscription created: ${data.planId}`,\r\n                status: 'pending',\r\n            },\r\n        });\r\n\r\n        // Track affiliate conversion if referral code exists\r\n        if (data.referralCode) {\r\n            try {\r\n                const plan = SUBSCRIPTION_PLANS[data.planId];\r\n                const amount = plan ? plan.price : 0;\r\n\r\n                await affiliateManager.trackConversion(\r\n                    data.referralCode,\r\n                    subscription.id,\r\n                    amount\r\n                );\r\n            } catch (error) {\r\n                console.error('Failed to track affiliate conversion:', error);\r\n                // Don't fail the subscription creation if affiliate tracking fails\r\n            }\r\n        }\r\n\r\n        return NextResponse.json({\r\n            subscription,\r\n            razorpaySubscription,\r\n            message: 'Subscription created successfully',\r\n        });\r\n    } catch (error: any) {\r\n        console.error('Create subscription error:', error);\r\n        if (error.name === 'ZodError') {\r\n            return NextResponse.json({ error: error.errors }, { status: 400 });\r\n        }\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        const subscriptions = await prisma.subscription.findMany({\r\n            where: { tenantId: tenant.tenantId },\r\n            orderBy: { createdAt: 'desc' },\r\n        });\r\n\r\n        return NextResponse.json({ subscriptions });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\billing\\usage\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'req' is defined but never used.","line":5,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[406,409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[406,409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { quotaManager } from '@/lib/razorpay/quota';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        const usage = await quotaManager.getUsage(tenant.tenantId);\r\n\r\n        return NextResponse.json({ usage });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\instagram\\accounts\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1236,1239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1236,1239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2024,2027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2024,2027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { z } from 'zod';\r\n\r\nconst updateConfigSchema = z.object({\r\n    enableAutoReply: z.boolean().optional(),\r\n    replyTemplateId: z.number().nullable().optional(),\r\n    dmTemplateId: z.number().nullable().optional(),\r\n});\r\n\r\nexport async function PATCH(\r\n    req: NextRequest,\r\n    { params }: { params: { id: string } }\r\n) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const body = await req.json();\r\n        const data = updateConfigSchema.parse(body);\r\n\r\n        // Verify account belongs to tenant\r\n        const account = await prisma.instagramAccount.findFirst({\r\n            where: {\r\n                id: parseInt(params.id),\r\n                tenantId: tenant.tenantId,\r\n            },\r\n        });\r\n\r\n        if (!account) {\r\n            return NextResponse.json({ error: 'Account not found' }, { status: 404 });\r\n        }\r\n\r\n        // Update config\r\n        const updated = await prisma.instagramAccount.update({\r\n            where: { id: account.id },\r\n            data,\r\n        });\r\n\r\n        return NextResponse.json(updated);\r\n    } catch (error: any) {\r\n        if (error.name === 'ZodError') {\r\n            return NextResponse.json({ error: error.errors }, { status: 400 });\r\n        }\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(\r\n    req: NextRequest,\r\n    { params }: { params: { id: string } }\r\n) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n\r\n        const account = await prisma.instagramAccount.findFirst({\r\n            where: {\r\n                id: parseInt(params.id),\r\n                tenantId: tenant.tenantId,\r\n            },\r\n        });\r\n\r\n        if (!account) {\r\n            return NextResponse.json({ error: 'Account not found' }, { status: 404 });\r\n        }\r\n\r\n        return NextResponse.json(account);\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\webhooks\\events\\[id]\\retry\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[980,983],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[980,983],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2113,2116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2113,2116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { requireTenant } from '@/lib/tenancy';\r\nimport { webhookQueue } from '@/lib/queue';\r\n\r\nexport async function POST(\r\n    req: NextRequest,\r\n    { params }: { params: { id: string } }\r\n) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const eventId = parseInt(params.id);\r\n\r\n        // Get the webhook event\r\n        const event = await prisma.webhookEvent.findFirst({\r\n            where: {\r\n                id: eventId,\r\n                tenantId: tenant.tenantId,\r\n            },\r\n        });\r\n\r\n        if (!event) {\r\n            return NextResponse.json({ error: 'Event not found' }, { status: 404 });\r\n        }\r\n\r\n        // Get the Instagram account for this event\r\n        // We need to find which account this event belongs to\r\n        // Since the event payload might contain the IG ID, let's extract it\r\n        const payload = event.payload as any;\r\n\r\n        // For manual retry, we need the Instagram account\r\n        const account = await prisma.instagramAccount.findFirst({\r\n            where: { tenantId: tenant.tenantId },\r\n            orderBy: { connectedAt: 'desc' },\r\n        });\r\n\r\n        if (!account) {\r\n            return NextResponse.json(\r\n                { error: 'No Instagram account found' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Re-queue the event\r\n        await webhookQueue.add('process-webhook', {\r\n            tenantId: tenant.tenantId,\r\n            instagramAccountId: account.instagramId,\r\n            accessToken: account.accessToken,\r\n            event: {\r\n                field: event.type,\r\n                value: payload,\r\n            },\r\n        });\r\n\r\n        // Mark as unprocessed so it can be processed again\r\n        await prisma.webhookEvent.update({\r\n            where: { id: event.id },\r\n            data: { processed: false },\r\n        });\r\n\r\n        return NextResponse.json({\r\n            message: 'Event re-queued successfully',\r\n            eventId: event.id,\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\webhooks\\events\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[573,576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[573,576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1388,1391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1388,1391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { requireTenant } from '@/lib/tenancy';\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const tenant = await requireTenant();\r\n        const searchParams = req.nextUrl.searchParams;\r\n\r\n        const page = parseInt(searchParams.get('page') || '1');\r\n        const limit = parseInt(searchParams.get('limit') || '50');\r\n        const processed = searchParams.get('processed');\r\n        const type = searchParams.get('type');\r\n\r\n        const where: any = {\r\n            tenantId: tenant.tenantId,\r\n        };\r\n\r\n        if (processed !== null) {\r\n            where.processed = processed === 'true';\r\n        }\r\n\r\n        if (type) {\r\n            where.type = type;\r\n        }\r\n\r\n        const [events, total] = await Promise.all([\r\n            prisma.webhookEvent.findMany({\r\n                where,\r\n                orderBy: { createdAt: 'desc' },\r\n                skip: (page - 1) * limit,\r\n                take: limit,\r\n            }),\r\n            prisma.webhookEvent.count({ where }),\r\n        ]);\r\n\r\n        return NextResponse.json({\r\n            events,\r\n            pagination: {\r\n                page,\r\n                limit,\r\n                total,\r\n                totalPages: Math.ceil(total / limit),\r\n            },\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\webhooks\\instagram\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2710,2713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2710,2713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport crypto from 'crypto';\r\nimport { prisma } from '@/lib/prisma';\r\nimport { webhookQueue } from '@/lib/queue';\r\n\r\nconst VERIFY_TOKEN = process.env.INSTAGRAM_WEBHOOK_VERIFY_TOKEN || 'my_secure_verify_token';\r\nconst APP_SECRET = process.env.INSTAGRAM_CLIENT_SECRET || '';\r\n\r\n// Helper to verify signature\r\nfunction verifySignature(body: string, signature: string) {\r\n    if (!APP_SECRET) return true; // Skip if no secret (dev)\r\n    const hmac = crypto.createHmac('sha1', APP_SECRET);\r\n    const digest = Buffer.from('sha1=' + hmac.update(body).digest('hex'), 'utf8');\r\n    const checksum = Buffer.from(signature, 'utf8');\r\n    return (checksum.length === digest.length && crypto.timingSafeEqual(digest, checksum));\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n    const searchParams = req.nextUrl.searchParams;\r\n    const mode = searchParams.get('hub.mode');\r\n    const token = searchParams.get('hub.verify_token');\r\n    const challenge = searchParams.get('hub.challenge');\r\n\r\n    if (mode === 'subscribe' && token === VERIFY_TOKEN) {\r\n        return new NextResponse(challenge, { status: 200 });\r\n    }\r\n\r\n    return new NextResponse('Forbidden', { status: 403 });\r\n}\r\n\r\nexport async function POST(req: NextRequest) {\r\n    const signature = req.headers.get('x-hub-signature');\r\n    const bodyText = await req.text();\r\n\r\n    if (!verifySignature(bodyText, signature || '')) {\r\n        // return new NextResponse('Unauthorized', { status: 401 });\r\n        // In dev, signature might be missing or hard to test with ngrok without strict setup. \r\n        // We'll warn but proceed if secret is missing.\r\n        if (APP_SECRET) console.warn('Webhook signature verification failed');\r\n    }\r\n\r\n    const body = JSON.parse(bodyText);\r\n\r\n    if (body.object === 'instagram') {\r\n        for (const entry of body.entry) {\r\n            // entry.id is the Instagram Business Account ID\r\n            const instagramAccountId = entry.id;\r\n\r\n            // Find tenant by IG ID\r\n            const account = await prisma.instagramAccount.findUnique({\r\n                where: { instagramId: instagramAccountId },\r\n                include: { tenant: true },\r\n            });\r\n\r\n            if (!account) {\r\n                console.warn(`Received webhook for unknown account: ${instagramAccountId}`);\r\n                continue;\r\n            }\r\n\r\n            for (const change of entry.changes) {\r\n                // Log the event\r\n                await prisma.webhookEvent.create({\r\n                    data: {\r\n                        tenantId: account.tenantId,\r\n                        type: change.field,\r\n                        payload: change.value as any,\r\n                        processed: false,\r\n                    },\r\n                });\r\n\r\n                // Add to BullMQ Queue for processing\r\n                await webhookQueue.add('process-webhook', {\r\n                    tenantId: account.tenantId,\r\n                    instagramAccountId: account.instagramId,\r\n                    accessToken: account.accessToken,\r\n                    event: change,\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    return new NextResponse('EVENT_RECEIVED', { status: 200 });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\webhooks\\razorpay\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":49,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1737,1740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1737,1740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":55,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1939,1942],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1939,1942],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2813,2816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2813,2816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3776,3779],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3776,3779],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":109,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3791,3794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3791,3794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4848,4851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4848,4851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":167,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5658,5661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5658,5661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { razorpayClient } from '@/lib/razorpay';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    const signature = req.headers.get('x-razorpay-signature');\r\n    const bodyText = await req.text();\r\n\r\n    // Verify webhook signature\r\n    if (!razorpayClient.verifyWebhookSignature(bodyText, signature || '')) {\r\n        console.error('Invalid Razorpay webhook signature');\r\n        return new NextResponse('Unauthorized', { status: 401 });\r\n    }\r\n\r\n    const body = JSON.parse(bodyText);\r\n    const event = body.event;\r\n    const payload = body.payload;\r\n\r\n    console.log(`Received Razorpay webhook: ${event}`);\r\n\r\n    try {\r\n        switch (event) {\r\n            case 'payment.captured':\r\n                await handlePaymentCaptured(payload.payment.entity);\r\n                break;\r\n\r\n            case 'subscription.activated':\r\n                await handleSubscriptionActivated(payload.subscription.entity);\r\n                break;\r\n\r\n            case 'subscription.charged':\r\n                await handleSubscriptionCharged(payload.subscription.entity, payload.payment?.entity);\r\n                break;\r\n\r\n            case 'subscription.cancelled':\r\n                await handleSubscriptionCancelled(payload.subscription.entity);\r\n                break;\r\n\r\n            case 'subscription.paused':\r\n            case 'subscription.resumed':\r\n                await handleSubscriptionStatusChange(payload.subscription.entity);\r\n                break;\r\n\r\n            default:\r\n                console.log(`Unhandled webhook event: ${event}`);\r\n        }\r\n\r\n        return new NextResponse('OK', { status: 200 });\r\n    } catch (error: any) {\r\n        console.error('Webhook processing error:', error);\r\n        return new NextResponse('Internal Server Error', { status: 500 });\r\n    }\r\n}\r\n\r\nasync function handlePaymentCaptured(payment: any) {\r\n    console.log('Payment captured:', payment.id);\r\n\r\n    // Find subscription by payment notes or subscription_id\r\n    const subscriptionId = payment.subscription_id;\r\n\r\n    if (subscriptionId) {\r\n        const subscription = await prisma.subscription.findUnique({\r\n            where: { razorpaySubId: subscriptionId },\r\n        });\r\n\r\n        if (subscription) {\r\n            await prisma.billingLog.create({\r\n                data: {\r\n                    tenantId: subscription.tenantId,\r\n                    amount: payment.amount / 100, // Razorpay amounts are in paise\r\n                    currency: payment.currency,\r\n                    description: `Payment captured for subscription ${subscriptionId}`,\r\n                    status: 'paid',\r\n                },\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionActivated(subscription: any) {\r\n    console.log('Subscription activated:', subscription.id);\r\n\r\n    const dbSubscription = await prisma.subscription.findUnique({\r\n        where: { razorpaySubId: subscription.id },\r\n    });\r\n\r\n    if (dbSubscription) {\r\n        await prisma.subscription.update({\r\n            where: { razorpaySubId: subscription.id },\r\n            data: {\r\n                status: 'ACTIVE',\r\n                currentPeriodStart: new Date(subscription.current_start * 1000),\r\n                currentPeriodEnd: new Date(subscription.current_end * 1000),\r\n            },\r\n        });\r\n\r\n        await prisma.billingLog.create({\r\n            data: {\r\n                tenantId: dbSubscription.tenantId,\r\n                amount: 0,\r\n                currency: 'INR',\r\n                description: `Subscription activated: ${subscription.id}`,\r\n                status: 'activated',\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionCharged(subscription: any, payment?: any) {\r\n    console.log('Subscription charged:', subscription.id);\r\n\r\n    const dbSubscription = await prisma.subscription.findUnique({\r\n        where: { razorpaySubId: subscription.id },\r\n    });\r\n\r\n    if (dbSubscription) {\r\n        await prisma.subscription.update({\r\n            where: { razorpaySubId: subscription.id },\r\n            data: {\r\n                status: 'ACTIVE',\r\n                currentPeriodStart: new Date(subscription.current_start * 1000),\r\n                currentPeriodEnd: new Date(subscription.current_end * 1000),\r\n            },\r\n        });\r\n\r\n        if (payment) {\r\n            await prisma.billingLog.create({\r\n                data: {\r\n                    tenantId: dbSubscription.tenantId,\r\n                    amount: payment.amount / 100,\r\n                    currency: payment.currency,\r\n                    description: `Subscription charged: ${subscription.id}`,\r\n                    status: 'paid',\r\n                },\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionCancelled(subscription: any) {\r\n    console.log('Subscription cancelled:', subscription.id);\r\n\r\n    const dbSubscription = await prisma.subscription.findUnique({\r\n        where: { razorpaySubId: subscription.id },\r\n    });\r\n\r\n    if (dbSubscription) {\r\n        await prisma.subscription.update({\r\n            where: { razorpaySubId: subscription.id },\r\n            data: {\r\n                status: 'CANCELED',\r\n            },\r\n        });\r\n\r\n        await prisma.billingLog.create({\r\n            data: {\r\n                tenantId: dbSubscription.tenantId,\r\n                amount: 0,\r\n                currency: 'INR',\r\n                description: `Subscription cancelled: ${subscription.id}`,\r\n                status: 'cancelled',\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nasync function handleSubscriptionStatusChange(subscription: any) {\r\n    const dbSubscription = await prisma.subscription.findUnique({\r\n        where: { razorpaySubId: subscription.id },\r\n    });\r\n\r\n    if (dbSubscription) {\r\n        let status: 'ACTIVE' | 'PAST_DUE' | 'CANCELED' | 'UNPAID' | 'TRIALING' = 'ACTIVE';\r\n\r\n        // Map Razorpay status to our status\r\n        if (subscription.status === 'active') status = 'ACTIVE';\r\n        else if (subscription.status === 'paused') status = 'PAST_DUE';\r\n        else if (subscription.status === 'cancelled') status = 'CANCELED';\r\n\r\n        await prisma.subscription.update({\r\n            where: { razorpaySubId: subscription.id },\r\n            data: { status },\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\api\\webhooks\\subscriptions\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1375,1378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1375,1378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2308,2311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2308,2311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3331,3334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3331,3334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { WebhookManager } from '@/lib/instagram/webhook-manager';\r\nimport { getServerSession } from 'next-auth';\r\nimport { authOptions } from '@/lib/auth/options';\r\n\r\nconst webhookManager = new WebhookManager();\r\nconst CALLBACK_URL = `${process.env.NEXTAUTH_URL}/api/webhooks/instagram`;\r\nconst VERIFY_TOKEN = process.env.INSTAGRAM_WEBHOOK_VERIFY_TOKEN || 'my_secure_verify_token';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    try {\r\n        const session = await getServerSession(authOptions);\r\n\r\n        if (!session || session.user.role !== 'SUPERADMIN') {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n        }\r\n\r\n        const body = await req.json();\r\n        const { pageAccessToken, appId } = body;\r\n\r\n        if (!pageAccessToken || !appId) {\r\n            return NextResponse.json(\r\n                { error: 'pageAccessToken and appId are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const result = await webhookManager.subscribeWebhooks(\r\n            pageAccessToken,\r\n            appId,\r\n            CALLBACK_URL,\r\n            VERIFY_TOKEN\r\n        );\r\n\r\n        return NextResponse.json({\r\n            message: 'Webhook subscription created successfully',\r\n            data: result,\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const session = await getServerSession(authOptions);\r\n\r\n        if (!session || session.user.role !== 'SUPERADMIN') {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n        }\r\n\r\n        const searchParams = req.nextUrl.searchParams;\r\n        const appId = searchParams.get('appId');\r\n        const appAccessToken = searchParams.get('appAccessToken');\r\n\r\n        if (!appId || !appAccessToken) {\r\n            return NextResponse.json(\r\n                { error: 'appId and appAccessToken are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const subscriptions = await webhookManager.listSubscriptions(appId, appAccessToken);\r\n\r\n        return NextResponse.json(subscriptions);\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function DELETE(req: NextRequest) {\r\n    try {\r\n        const session = await getServerSession(authOptions);\r\n\r\n        if (!session || session.user.role !== 'SUPERADMIN') {\r\n            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n        }\r\n\r\n        const searchParams = req.nextUrl.searchParams;\r\n        const appId = searchParams.get('appId');\r\n        const appAccessToken = searchParams.get('appAccessToken');\r\n\r\n        if (!appId || !appAccessToken) {\r\n            return NextResponse.json(\r\n                { error: 'appId and appAccessToken are required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const result = await webhookManager.deleteSubscription(appId, appAccessToken);\r\n\r\n        return NextResponse.json({\r\n            message: 'Webhook subscription deleted successfully',\r\n            data: result,\r\n        });\r\n    } catch (error: any) {\r\n        return NextResponse.json({ error: error.message }, { status: 500 });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\dashboard\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\components\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\components\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\affiliate\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1453,1456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1453,1456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2537,2540],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2537,2540],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from '@/lib/prisma';\r\nimport crypto from 'crypto';\r\n\r\nexport interface AffiliateConfig {\r\n    commissionRate: number; // Percentage (e.g., 30 for 30%)\r\n    cookieDuration: number; // Days\r\n    minPayoutAmount: number; // Minimum payout threshold in INR\r\n}\r\n\r\nexport const AFFILIATE_CONFIG: AffiliateConfig = {\r\n    commissionRate: 30, // 30% commission\r\n    cookieDuration: 30, // 30-day cookie\r\n    minPayoutAmount: 1000, // â‚¹1000 minimum payout\r\n};\r\n\r\nexport class AffiliateManager {\r\n    /**\r\n     * Generate unique affiliate code for a user\r\n     */\r\n    async generateAffiliateCode(userId: number, name: string): Promise<string> {\r\n        // Create a unique code based on user ID and random string\r\n        const randomPart = crypto.randomBytes(4).toString('hex');\r\n        const baseCode = name\r\n            .toLowerCase()\r\n            .replace(/[^a-z0-9]/g, '')\r\n            .substring(0, 8);\r\n\r\n        const code = `${baseCode}-${randomPart}`;\r\n\r\n        // Ensure uniqueness\r\n        const existing = await prisma.affiliate.findUnique({\r\n            where: { referralCode: code },\r\n        });\r\n\r\n        if (existing) {\r\n            // Recursively try again with new random part\r\n            return this.generateAffiliateCode(userId, name);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Create or get affiliate record for a user\r\n     */\r\n    async enrollAffiliate(userId: number, tenantId: number): Promise<any> {\r\n        // Check if already enrolled\r\n        const existing = await prisma.affiliate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (existing) {\r\n            return existing;\r\n        }\r\n\r\n        // Get user details\r\n        const user = await prisma.user.findUnique({\r\n            where: { id: userId },\r\n        });\r\n\r\n        if (!user) {\r\n            throw new Error('User not found');\r\n        }\r\n\r\n        // Generate code\r\n        const referralCode = await this.generateAffiliateCode(userId, user.name || 'user');\r\n\r\n        // Create affiliate record\r\n        const affiliate = await prisma.affiliate.create({\r\n            data: {\r\n                userId,\r\n                tenantId,\r\n                referralCode,\r\n                totalEarnings: 0,\r\n                pendingPayout: 0,\r\n                totalReferrals: 0,\r\n            },\r\n        });\r\n\r\n        return affiliate;\r\n    }\r\n\r\n    /**\r\n     * Track a referral (when someone clicks affiliate link)\r\n     */\r\n    async trackReferral(referralCode: string, metadata?: Record<string, any>): Promise<void> {\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { referralCode },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            throw new Error('Invalid referral code');\r\n        }\r\n\r\n        // Increment click count or store in a separate tracking table if needed\r\n        // For now, we'll just validate the code\r\n        console.log(`Tracked referral for code: ${referralCode}`, metadata);\r\n    }\r\n\r\n    /**\r\n     * Track a conversion (when referred user subscribes)\r\n     */\r\n    async trackConversion(\r\n        referralCode: string,\r\n        subscriptionId: number,\r\n        amount: number\r\n    ): Promise<void> {\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { referralCode },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            throw new Error('Invalid referral code');\r\n        }\r\n\r\n        // Calculate commission\r\n        const commission = (amount * AFFILIATE_CONFIG.commissionRate) / 100;\r\n\r\n        // Update affiliate earnings\r\n        await prisma.affiliate.update({\r\n            where: { id: affiliate.id },\r\n            data: {\r\n                totalEarnings: { increment: commission },\r\n                pendingPayout: { increment: commission },\r\n                totalReferrals: { increment: 1 },\r\n            },\r\n        });\r\n\r\n        console.log(\r\n            `Tracked conversion for ${referralCode}: â‚¹${amount} -> â‚¹${commission} commission`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Process payout for an affiliate\r\n     */\r\n    async processPayout(affiliateId: number, amount: number): Promise<void> {\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { id: affiliateId },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            throw new Error('Affiliate not found');\r\n        }\r\n\r\n        if (affiliate.pendingPayout < amount) {\r\n            throw new Error('Insufficient pending payout');\r\n        }\r\n\r\n        if (amount < AFFILIATE_CONFIG.minPayoutAmount) {\r\n            throw new Error(`Minimum payout amount is â‚¹${AFFILIATE_CONFIG.minPayoutAmount}`);\r\n        }\r\n\r\n        // Update affiliate\r\n        await prisma.affiliate.update({\r\n            where: { id: affiliateId },\r\n            data: {\r\n                pendingPayout: { decrement: amount },\r\n            },\r\n        });\r\n\r\n        console.log(`Processed payout of â‚¹${amount} for affiliate ${affiliateId}`);\r\n    }\r\n\r\n    /**\r\n     * Get affiliate statistics\r\n     */\r\n    async getAffiliateStats(userId: number) {\r\n        const affiliate = await prisma.affiliate.findUnique({\r\n            where: { userId },\r\n        });\r\n\r\n        if (!affiliate) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            referralCode: affiliate.referralCode,\r\n            totalEarnings: affiliate.totalEarnings,\r\n            pendingPayout: affiliate.pendingPayout,\r\n            totalReferrals: affiliate.totalReferrals,\r\n            referralUrl: `${process.env.NEXTAUTH_URL}/signup?ref=${affiliate.referralCode}`,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get top affiliates (leaderboard)\r\n     */\r\n    async getTopAffiliates(limit: number = 10) {\r\n        return prisma.affiliate.findMany({\r\n            take: limit,\r\n            orderBy: { totalEarnings: 'desc' },\r\n            include: {\r\n                user: {\r\n                    select: {\r\n                        name: true,\r\n                        email: true,\r\n                    },\r\n                },\r\n            },\r\n        });\r\n    }\r\n}\r\n\r\nexport const affiliateManager = new AffiliateManager();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\auth\\options.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\instagram\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\instagram\\dm-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":82,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2631,2634],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2631,2634],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from '@/lib/prisma';\r\nimport { InstagramClient } from '@/lib/instagram/graph';\r\n\r\ninterface DMJobData {\r\n    tenantId: number;\r\n    recipientId: string; // Instagram scoped user ID\r\n    username: string;\r\n    dmTemplateId: number;\r\n    instagramAccountId?: string;\r\n    accessToken?: string;\r\n}\r\n\r\nexport class DMEngine {\r\n    async sendDM(data: DMJobData) {\r\n        const { tenantId, recipientId, username, dmTemplateId } = data;\r\n\r\n        try {\r\n            // 1. Get DM Template\r\n            const template = await prisma.template.findFirst({\r\n                where: {\r\n                    tenantId,\r\n                    id: dmTemplateId,\r\n                    type: 'DM',\r\n                },\r\n            });\r\n\r\n            if (!template) {\r\n                throw new Error(`DM template ${dmTemplateId} not found`);\r\n            }\r\n\r\n            // 2. Get Instagram Account (if not provided in job data)\r\n            let accessToken = data.accessToken;\r\n            let instagramId = data.instagramAccountId;\r\n\r\n            if (!accessToken || !instagramId) {\r\n                const account = await prisma.instagramAccount.findFirst({\r\n                    where: { tenantId },\r\n                    orderBy: { connectedAt: 'desc' }, // Use most recent\r\n                });\r\n\r\n                if (!account) {\r\n                    throw new Error('No Instagram account connected');\r\n                }\r\n\r\n                accessToken = account.accessToken;\r\n                instagramId = account.instagramId;\r\n            }\r\n\r\n            // 3. Replace template variables\r\n            const messageText = this.replaceVariables(template.content, {\r\n                username,\r\n                recipient_id: recipientId,\r\n            });\r\n\r\n            // 4. Send DM via Instagram API\r\n            if (!accessToken || !instagramId) {\r\n                throw new Error('Instagram credentials not available');\r\n            }\r\n\r\n            const client = new InstagramClient({\r\n                accessToken,\r\n                instagramId,\r\n            });\r\n\r\n            await client.sendDM(recipientId, messageText);\r\n\r\n            // 5. Log Success\r\n            await this.logDM(tenantId, username, messageText, 'SUCCESS', null);\r\n\r\n            // 6. Log automation event\r\n            await prisma.automationLog.create({\r\n                data: {\r\n                    tenantId,\r\n                    action: 'SEND_DM',\r\n                    details: `Sent DM to @${username}`,\r\n                    status: 'SUCCESS',\r\n                },\r\n            });\r\n\r\n            return { success: true };\r\n\r\n        } catch (error: any) {\r\n            console.error('Error sending DM:', error);\r\n\r\n            // Log failure\r\n            await this.logDM(tenantId, username, '', 'FAILED', error.message);\r\n\r\n            // Rethrow to trigger BullMQ retry\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    private async logDM(\r\n        tenantId: number,\r\n        username: string,\r\n        messageText: string,\r\n        status: 'PENDING' | 'SUCCESS' | 'FAILED' | 'SKIPPED',\r\n        error: string | null\r\n    ) {\r\n        await prisma.dMLog.create({\r\n            data: {\r\n                tenantId,\r\n                username,\r\n                messageText,\r\n                status,\r\n                error,\r\n            },\r\n        });\r\n    }\r\n\r\n    private replaceVariables(text: string, vars: Record<string, string>): string {\r\n        let result = text;\r\n        for (const [key, value] of Object.entries(vars)) {\r\n            result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\instagram\\graph.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'targetUsername' is defined but never used.","line":39,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const GRAPH_API_URL = 'https://graph.facebook.com/v19.0';\r\n\r\ninterface InstagramConfig {\r\n    accessToken: string;\r\n    instagramId: string; // The IG Business Account ID\r\n}\r\n\r\nexport class InstagramClient {\r\n    private accessToken: string;\r\n    private instagramId: string;\r\n\r\n    constructor(config: InstagramConfig) {\r\n        this.accessToken = config.accessToken;\r\n        this.instagramId = config.instagramId;\r\n    }\r\n\r\n    private async request(endpoint: string, options: RequestInit = {}) {\r\n        const url = `${GRAPH_API_URL}/${endpoint}`;\r\n        const headers = {\r\n            'Authorization': `Bearer ${this.accessToken}`,\r\n            'Content-Type': 'application/json',\r\n            ...options.headers,\r\n        };\r\n\r\n        const response = await fetch(url, { ...options, headers });\r\n        const data = await response.json();\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Instagram API Error: ${data.error?.message || response.statusText}`);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    async getProfile() {\r\n        return this.request(`${this.instagramId}?fields=id,username,name,profile_picture_url`);\r\n    }\r\n\r\n    async checkFollow(targetUsername: string): Promise<boolean> {\r\n        // Note: The API doesn't have a direct \"check if X follows me\" for IG Business accounts easily \r\n        // without iterating followers or using specific endpoints that might be restricted.\r\n        // However, for \"Basic Display\" it's different. For \"Graph API\" (Business), \r\n        // we usually can't easily check if a *random* user follows us unless we have their ID.\r\n        // But if we have the user's scoped ID (from a webhook interaction), we might be able to check.\r\n        // A common workaround is to try to get the relationship status if allowed, or assume true for MVP if restricted.\r\n        // CORRECT APPROACH: Use the `business_discovery` endpoint to get data about the user if possible, \r\n        // or if we have the user's ID, check `/me/followers` (but that's paginated and heavy).\r\n        // ACTUALLY: There isn't a simple \"does X follow me\" endpoint in the official Graph API for IG Business \r\n        // that is efficient for high volume. \r\n        // Many automations use the \"follower_count\" or just skip this check if strict API compliance is needed.\r\n        // HOWEVER, if the user interacts with us, we get their ID.\r\n        // We will implement a placeholder that returns true for now, or a \"best effort\" if we find a valid endpoint.\r\n        // Let's stick to a mock implementation for the \"check\" as it's complex and often requires specific permissions.\r\n        // Real implementation would involve: GET /{ig-user-id}?fields=business_discovery.username({targetUsername}){follows_count} (not quite).\r\n\r\n        // For this system, we will assume we can't strictly enforce it without extra permissions or a private API (which we avoid).\r\n        // We'll return true to allow the automation to proceed, or log a warning.\r\n        return true;\r\n    }\r\n\r\n    async replyToComment(commentId: string, message: string) {\r\n        return this.request(`${commentId}/replies`, {\r\n            method: 'POST',\r\n            body: JSON.stringify({ message }),\r\n        });\r\n    }\r\n\r\n    async sendDM(recipientId: string, message: string) {\r\n        // Note: Sending DMs requires the 'instagram_manage_messages' permission.\r\n        // We use the /messages endpoint.\r\n        return this.request(`${this.instagramId}/messages`, {\r\n            method: 'POST',\r\n            body: JSON.stringify({\r\n                recipient: { id: recipientId },\r\n                message: { text: message },\r\n            }),\r\n        });\r\n    }\r\n\r\n    async getMedia(mediaId: string) {\r\n        return this.request(`${mediaId}?fields=id,caption,media_type,media_url,permalink`);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\instagram\\reply-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3414,3417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3414,3417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3606,3609],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3606,3609],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from '@/lib/prisma';\r\nimport { InstagramClient } from '@/lib/instagram/graph';\r\nimport { dmQueue } from '@/lib/queue';\r\nimport { quotaManager } from '@/lib/razorpay/quota';\r\nimport { LogStatus } from '@prisma/client';\r\n\r\ninterface CommentEvent {\r\n    id: string; // comment ID\r\n    text: string;\r\n    from: {\r\n        id: string;\r\n        username: string;\r\n    };\r\n    media: {\r\n        id: string;\r\n    };\r\n}\r\n\r\nexport class ReplyEngine {\r\n    async processComment(\r\n        tenantId: number,\r\n        instagramAccountId: string,\r\n        accessToken: string,\r\n        event: CommentEvent\r\n    ) {\r\n        try {\r\n            // 0. Check quota\r\n            const canAutomate = await quotaManager.canAutomation(tenantId);\r\n            if (!canAutomate) {\r\n                console.warn(`Tenant ${tenantId} has exceeded automation quota`);\r\n                await this.logReply(tenantId, event, 'SKIPPED', 'Automation quota exceeded');\r\n                return;\r\n            }\r\n\r\n            // 1. Get Instagram Account config\r\n            const igAccount = await prisma.instagramAccount.findUnique({\r\n                where: { instagramId: instagramAccountId },\r\n            });\r\n\r\n            if (!igAccount || !igAccount.enableAutoReply) {\r\n                console.log(`Auto-reply disabled for account ${instagramAccountId}`);\r\n                return;\r\n            }\r\n\r\n            // 2. Get Reply Template\r\n            const replyTemplate = await prisma.template.findFirst({\r\n                where: {\r\n                    tenantId,\r\n                    id: igAccount.replyTemplateId || undefined,\r\n                    type: 'REPLY',\r\n                },\r\n                orderBy: {\r\n                    isDefault: 'desc', // Prefer default if no specific template set\r\n                },\r\n            });\r\n\r\n            if (!replyTemplate) {\r\n                console.warn(`No reply template found for tenant ${tenantId}`);\r\n                await this.logReply(tenantId, event, 'FAILED', 'No reply template configured');\r\n                return;\r\n            }\r\n\r\n            // 3. Prepare reply text (with variable substitution)\r\n            const replyText = this.replaceVariables(replyTemplate.content, {\r\n                username: event.from.username,\r\n                comment: event.text,\r\n            });\r\n\r\n            // 4. Post Reply using Instagram Graph API\r\n            const client = new InstagramClient({\r\n                accessToken,\r\n                instagramId: instagramAccountId,\r\n            });\r\n\r\n            try {\r\n                await client.replyToComment(event.id, replyText);\r\n\r\n                // 5. Log Success\r\n                await this.logReply(tenantId, event, 'SUCCESS', null, replyText);\r\n\r\n                // 6. Queue DM Task (if DM template configured)\r\n                if (igAccount.dmTemplateId) {\r\n                    await this.queueDM(tenantId, event.from.id, event.from.username, igAccount.dmTemplateId);\r\n                }\r\n\r\n                // 7. Log Automation Event\r\n                await prisma.automationLog.create({\r\n                    data: {\r\n                        tenantId,\r\n                        action: 'COMMENT_REPLY',\r\n                        details: `Replied to comment ${event.id} from @${event.from.username}`,\r\n                        status: 'SUCCESS',\r\n                    },\r\n                });\r\n\r\n            } catch (error: any) {\r\n                console.error('Error posting reply:', error);\r\n                await this.logReply(tenantId, event, 'FAILED', error.message);\r\n            }\r\n\r\n        } catch (error: any) {\r\n            console.error('Error in processComment:', error);\r\n        }\r\n    }\r\n\r\n    private async logReply(\r\n        tenantId: number,\r\n        event: CommentEvent,\r\n        status: LogStatus,\r\n        error: string | null,\r\n        replyText?: string\r\n    ) {\r\n        await prisma.replyLog.create({\r\n            data: {\r\n                tenantId,\r\n                commentId: event.id,\r\n                mediaId: event.media.id,\r\n                username: event.from.username,\r\n                replyText: replyText || '',\r\n                status,\r\n                error,\r\n            },\r\n        });\r\n    }\r\n\r\n    private async queueDM(\r\n        tenantId: number,\r\n        recipientId: string,\r\n        username: string,\r\n        dmTemplateId: number\r\n    ) {\r\n        await dmQueue.add('send-dm', {\r\n            tenantId,\r\n            recipientId,\r\n            username,\r\n            dmTemplateId,\r\n        });\r\n    }\r\n\r\n    private replaceVariables(text: string, vars: Record<string, string>): string {\r\n        let result = text;\r\n        for (const [key, value] of Object.entries(vars)) {\r\n            result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\instagram\\webhook-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WebhookSubscription' is defined but never used.","line":3,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const GRAPH_API_URL = 'https://graph.facebook.com/v19.0';\r\n\r\ninterface WebhookSubscription {\r\n    object: string;\r\n    callback_url: string;\r\n    verify_token: string;\r\n    fields: string[];\r\n}\r\n\r\nexport class WebhookManager {\r\n    /**\r\n     * Subscribe to Instagram webhooks for a given page/app\r\n     * @param pageAccessToken The Page Access Token (not User token)\r\n     * @param appId Instagram App ID\r\n     */\r\n    async subscribeWebhooks(\r\n        pageAccessToken: string,\r\n        appId: string,\r\n        callbackUrl: string,\r\n        verifyToken: string\r\n    ) {\r\n        const fields = [\r\n            'comments',\r\n            'mentions',\r\n            'story_insights',\r\n            'live_comments',\r\n        ];\r\n\r\n        const url = `${GRAPH_API_URL}/${appId}/subscriptions`;\r\n\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                object: 'instagram',\r\n                callback_url: callbackUrl,\r\n                verify_token: verifyToken,\r\n                fields: fields.join(','),\r\n                access_token: pageAccessToken,\r\n            }),\r\n        });\r\n\r\n        const data = await response.json();\r\n\r\n        if (!response.ok) {\r\n            throw new Error(data.error?.message || 'Failed to subscribe webhooks');\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * List active webhook subscriptions\r\n     */\r\n    async listSubscriptions(appId: string, appAccessToken: string) {\r\n        const url = `${GRAPH_API_URL}/${appId}/subscriptions?access_token=${appAccessToken}`;\r\n\r\n        const response = await fetch(url);\r\n        const data = await response.json();\r\n\r\n        if (!response.ok) {\r\n            throw new Error(data.error?.message || 'Failed to list subscriptions');\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Delete webhook subscription\r\n     */\r\n    async deleteSubscription(appId: string, appAccessToken: string, object: string = 'instagram') {\r\n        const url = `${GRAPH_API_URL}/${appId}/subscriptions?object=${object}&access_token=${appAccessToken}`;\r\n\r\n        const response = await fetch(url, { method: 'DELETE' });\r\n        const data = await response.json();\r\n\r\n        if (!response.ok) {\r\n            throw new Error(data.error?.message || 'Failed to delete subscription');\r\n        }\r\n\r\n        return data;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\prisma\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\queue\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'redis' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Queue } from 'bullmq';\r\nimport { redis } from '@/lib/redis';\r\n\r\n// Reuse the ioredis connection from lib/redis if possible, \r\n// but BullMQ usually needs its own connection settings or instance.\r\n// We'll pass the connection options.\r\n\r\nconst connection = {\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: parseInt(process.env.REDIS_PORT || '6379'),\r\n    password: process.env.REDIS_PASSWORD,\r\n};\r\n\r\nexport const dmQueue = new Queue('dm-queue', {\r\n    connection,\r\n    defaultJobOptions: {\r\n        attempts: 3,\r\n        backoff: {\r\n            type: 'exponential',\r\n            delay: 1000,\r\n        },\r\n        removeOnComplete: true,\r\n    },\r\n});\r\n\r\nexport const webhookQueue = new Queue('webhook-queue', {\r\n    connection,\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\razorpay\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\razorpay\\plans.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\razorpay\\quota.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tenantId' is defined but never used.","line":119,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { prisma } from '@/lib/prisma';\r\nimport { SUBSCRIPTION_PLANS } from '@/lib/razorpay/plans';\r\n\r\nexport interface UsageQuota {\r\n    automations: {\r\n        used: number;\r\n        limit: number;\r\n        remaining: number;\r\n    };\r\n    accounts: {\r\n        used: number;\r\n        limit: number;\r\n        remaining: number;\r\n    };\r\n    templates: {\r\n        used: number;\r\n        limit: number;\r\n        remaining: number;\r\n    };\r\n}\r\n\r\nexport class QuotaManager {\r\n    /**\r\n     * Get current usage and limits for a tenant\r\n     */\r\n    async getUsage(tenantId: number): Promise<UsageQuota> {\r\n        // Get active subscription\r\n        const subscription = await prisma.subscription.findFirst({\r\n            where: {\r\n                tenantId,\r\n                status: { in: ['ACTIVE', 'TRIALING'] },\r\n            },\r\n        });\r\n\r\n        // Default limits if no subscription (free tier or grace period)\r\n        let limits = {\r\n            automations: 100,\r\n            accounts: 1,\r\n            templates: 3,\r\n        };\r\n\r\n        if (subscription) {\r\n            const plan = SUBSCRIPTION_PLANS[subscription.planId];\r\n            if (plan) {\r\n                limits = plan.limits;\r\n            }\r\n        }\r\n\r\n        // Get current month's automation count\r\n        const startOfMonth = new Date();\r\n        startOfMonth.setDate(1);\r\n        startOfMonth.setHours(0, 0, 0, 0);\r\n\r\n        const automationCount = await prisma.automationLog.count({\r\n            where: {\r\n                tenantId,\r\n                createdAt: { gte: startOfMonth },\r\n            },\r\n        });\r\n\r\n        // Get account count\r\n        const accountCount = await prisma.instagramAccount.count({\r\n            where: { tenantId },\r\n        });\r\n\r\n        // Get template count\r\n        const templateCount = await prisma.template.count({\r\n            where: { tenantId },\r\n        });\r\n\r\n        return {\r\n            automations: {\r\n                used: automationCount,\r\n                limit: limits.automations,\r\n                remaining: Math.max(0, limits.automations - automationCount),\r\n            },\r\n            accounts: {\r\n                used: accountCount,\r\n                limit: limits.accounts,\r\n                remaining: Math.max(0, limits.accounts - accountCount),\r\n            },\r\n            templates: {\r\n                used: templateCount,\r\n                limit: limits.templates === -1 ? -1 : limits.templates,\r\n                remaining: limits.templates === -1 ? -1 : Math.max(0, limits.templates - templateCount),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Check if tenant can perform an automation\r\n     */\r\n    async canAutomation(tenantId: number): Promise<boolean> {\r\n        const usage = await this.getUsage(tenantId);\r\n        return usage.automations.remaining > 0;\r\n    }\r\n\r\n    /**\r\n     * Check if tenant can add more accounts\r\n     */\r\n    async canAddAccount(tenantId: number): Promise<boolean> {\r\n        const usage = await this.getUsage(tenantId);\r\n        return usage.accounts.remaining > 0;\r\n    }\r\n\r\n    /**\r\n     * Check if tenant can add more templates\r\n     */\r\n    async canAddTemplate(tenantId: number): Promise<boolean> {\r\n        const usage = await this.getUsage(tenantId);\r\n        return usage.templates.limit === -1 || usage.templates.remaining > 0;\r\n    }\r\n\r\n    /**\r\n     * Increment automation usage (called after successful automation)\r\n     * This is already tracked via automationLog creation, so this is a no-op\r\n     * but kept for explicit usage tracking if needed\r\n     */\r\n    async trackAutomation(tenantId: number): Promise<void> {\r\n        // Already tracked via automationLog\r\n        // This method can be extended for additional tracking if needed\r\n    }\r\n}\r\n\r\nexport const quotaManager = new QuotaManager();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\redis\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\lib\\tenancy\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\next.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\postcss.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\scripts\\migrate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\scripts\\seed.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\types\\next-auth.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\workers\\dmWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\workers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\workers\\replyWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ravul\\OneDrive\\Desktop\\instagramAutomation\\workers\\webhookWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1677,1680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1677,1680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Webhook Worker\r\n * NOTE: This functionality is now handled by replyWorker.ts\r\n * This file is kept for reference/compatibility but the actual\r\n * webhook processing happens in workers/replyWorker.ts\r\n */\r\n\r\nimport { Worker } from 'bullmq';\r\nimport { ReplyEngine } from '@/lib/instagram/reply-engine';\r\nimport { prisma } from '@/lib/prisma';\r\n\r\nconst connection = {\r\n    host: process.env.REDIS_HOST || 'localhost',\r\n    port: parseInt(process.env.REDIS_PORT || '6379'),\r\n    password: process.env.REDIS_PASSWORD,\r\n};\r\n\r\nconst replyEngine = new ReplyEngine();\r\n\r\nexport const webhookWorker = new Worker(\r\n    'webhook-queue',\r\n    async (job) => {\r\n        const { tenantId, instagramAccountId, accessToken, event } = job.data;\r\n\r\n        try {\r\n            // Process different event types\r\n            if (event.field === 'comments') {\r\n                await replyEngine.processComment(\r\n                    tenantId,\r\n                    instagramAccountId,\r\n                    accessToken,\r\n                    event.value\r\n                );\r\n            }\r\n\r\n            // Mark webhook event as processed in DB if we have the event ID\r\n            // We need to find the event by payload match\r\n            await prisma.webhookEvent.updateMany({\r\n                where: {\r\n                    tenantId,\r\n                    type: event.field,\r\n                    processed: false,\r\n                },\r\n                data: {\r\n                    processed: true,\r\n                },\r\n            });\r\n\r\n            // Can handle other event types here:\r\n            // - mentions\r\n            // - story_replies\r\n            // - etc.\r\n        } catch (error: any) {\r\n            console.error('Webhook processing error:', error);\r\n            throw error; // Re-throw to trigger retry\r\n        }\r\n    },\r\n    {\r\n        connection,\r\n        concurrency: 5,\r\n        limiter: {\r\n            max: 20,\r\n            duration: 60000,\r\n        },\r\n    }\r\n);\r\n\r\nwebhookWorker.on('completed', (job) => {\r\n    console.log(`Webhook Job ${job.id} completed`);\r\n});\r\n\r\nwebhookWorker.on('failed', (job, err) => {\r\n    console.error(`Webhook Job ${job?.id} failed:`, err);\r\n});\r\n\r\nconsole.log('Webhook Worker started');\r\n","usedDeprecatedRules":[]}]